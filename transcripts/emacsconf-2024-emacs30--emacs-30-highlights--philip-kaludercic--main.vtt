WEBVTT

00:00:00.000 --> 00:00:07.760
 Hello and welcome to Emax30 highlights at Emax2024. Before I begin, I'd like to thank

00:00:07.760 --> 00:00:12.560
 the organizers and everyone involved for pushing this all together. While the talk is being

00:00:12.560 --> 00:00:16.600
 prerecorded, my experience from the last few years ensures me that it will be a great

00:00:16.600 --> 00:00:21.520
 experience for everyone. My name is Philip Callagyarchich, I am a

00:00:21.520 --> 00:00:26.680
 core contributor and Al Paco maintainer. I was honored when Sasha asked me to take over

00:00:26.680 --> 00:00:32.120
 the slot for this year. In the past few iterations, Jon Weekly has filled a similar presentation

00:00:32.120 --> 00:00:38.320
 focusing on more general Emax development updates. This year, I will specifically focus

00:00:38.320 --> 00:00:43.400
 on highlight features from the upcoming Emax30 release, which might or might not have been

00:00:43.400 --> 00:00:50.640
 released by the time you are seeing this. As you can imagine, everything you're about

00:00:50.640 --> 00:00:58.500
 Emax can always be found in the Emax News file. Alternatively, if one doesn't want to read

00:00:58.500 --> 00:01:05.480
 through the multiple thousand lines here, one can also take a look at the Emax FAQ and

00:01:05.480 --> 00:01:15.440
 then go to what's different about Emax30. Next to these two official options, I also have

00:01:15.440 --> 00:01:25.060
 a page on Emax Wicking called Emax30 highlights some of the interesting features with some

00:01:25.060 --> 00:01:30.160
 context and suggestions on how to try them out. This is more of a collaborative effort,

00:01:30.160 --> 00:01:35.680
 so if you see this and think something is missing, feel free to add it. So without further

00:01:35.680 --> 00:01:42.720
 ado, let's begin taking a look at new features in Emax30. The biggest one in the one I

00:01:42.720 --> 00:01:51.000
 once mentioned first is Android support, native Android support. As you can see here,

00:01:51.000 --> 00:01:56.560
 Emax has been ported to the Android operating system. What this means is that from Emax30 onwards,

00:01:56.560 --> 00:02:06.880
 you can build Android to target Android devices natively and using a graphical interface.

00:02:06.880 --> 00:02:11.320
 While this has been possible to run Emax inside of Terminal Emulators in Android for a while,

00:02:11.320 --> 00:02:17.840
 this actually means that you can use Emax on an Android device or phone or tablet and have

00:02:17.840 --> 00:02:23.720
 all the usual advantages from Gweemax, such as the ability to vines or commands without

00:02:23.720 --> 00:02:29.560
 having to worry about all keys without having to worry about Terminal compatibility issues,

00:02:29.560 --> 00:02:36.120
 displaying images and multiple fonts on the same display of different sizes. I should have

00:02:36.120 --> 00:02:45.440
 a recording of that somewhere here, which I made earlier on my phone because I'm recording

00:02:45.440 --> 00:02:51.480
 this on the laptop, where we can see how touch interaction works on an Android phone so

00:02:51.480 --> 00:02:56.760
 I can switch between buffers and here I've connected an external keyboard, opening the

00:02:56.760 --> 00:03:03.960
 Emax website and we have images that we can interact with or we could resize them if we

00:03:03.960 --> 00:03:11.120
 wanted to, with the image resizing commands, pitch to zoom works, so it does realize what

00:03:11.120 --> 00:03:16.440
 touch screen interactions are with an external mouse and, for example, enabling context menu

00:03:16.440 --> 00:03:26.480
 mode. I can even pop up little interaction windows, which one would usually also know from

00:03:26.480 --> 00:03:34.520
 Gweemax, but Tweemax also supports them since a while now. In this case, I'm demonstrating

00:03:34.520 --> 00:03:40.760
 how even the touch screen events can be inspected using the usual hot-help system and how

00:03:40.760 --> 00:03:47.280
 context mode notices where we are and allows me to, for example, evaluate this specific

00:03:47.280 --> 00:03:58.600
 region, which I've highlighted down there, finding a command to touch screen scroll. One should

00:03:58.600 --> 00:04:04.280
 note that these additions, for example, touch screen interaction are not specific to Android,

00:04:04.280 --> 00:04:10.840
 but they also are supported in other operating systems such as, well, Walens and Exog, which

00:04:10.840 --> 00:04:16.320
 are not operating systems, and Windows. Insofar, they have touch screen and devices, have

00:04:16.320 --> 00:04:22.920
 touch screen support. One should mention, or I want to mention that the main developer behind

00:04:22.920 --> 00:04:28.240
 this feature, Paulu, should be complemented for the additional effort he put into making

00:04:28.240 --> 00:04:34.240
 sure that Emax and Android, Emax for Android, can be built using only a free software toolchain,

00:04:34.240 --> 00:04:40.840
 which is certainly not something one has come to expect from working on Android applications,

00:04:40.840 --> 00:04:46.680
 as usually you have to agree to some terms and conditions for Google's specific software.

00:04:46.680 --> 00:04:51.400
 Final notice is that if you try and look for this online, there is an APK, which there

00:04:51.400 --> 00:04:57.040
 are APKs you can find, but some of them might be outdated. The best of my knowledge, Paulu

00:04:57.040 --> 00:05:07.880
 has Emax 30 Android Source Vorge, set up some system here in Source Vorge. There are regular

00:05:07.880 --> 00:05:15.760
 and go away. There are regular and updated APK files which you can download to avoid having

00:05:15.760 --> 00:05:20.520
 to build it yourself, but testing out the newest version in case there are some bugs which

00:05:20.520 --> 00:05:33.400
 you'd like to report. Next up, Vorge Key, is a package which has now been moved from

00:05:33.400 --> 00:05:40.260
 Albert to the core. If you haven't heard of Vorge Key before, the idea is, or the general

00:05:40.260 --> 00:05:47.760
 pitches at Vorge Key is a additional documentation interface for Emax for displaying various keys

00:05:47.760 --> 00:05:56.400
 which you could input or various keys and keymaps that have been partially inputted. The better

00:05:56.400 --> 00:06:01.640
 way to demonstrate this or to explain this is just a show it. If we enable the which key

00:06:01.640 --> 00:06:07.200
 mode, it's a global minor mode, then I can press, for example, Control X, which is a prefix

00:06:07.200 --> 00:06:11.760
 for the Control X. Keymap and then down here in the buffer, in this window down here we

00:06:11.760 --> 00:06:18.880
 see various commands which we could invoke and the keys to invoke them with. For example,

00:06:18.880 --> 00:06:24.960
 if I wanted to say, Control X, I for insert file, then I just have to press I, which was,

00:06:24.960 --> 00:06:31.760
 I mean, so highlight this once again. It should be down here, yes. Pressing I without having

00:06:31.760 --> 00:06:38.600
 to repeat the entire key code again, but partial key code again just works. This is different

00:06:38.600 --> 00:06:44.920
 from the feature which Emax has already, which is just to, if you have input to the partial

00:06:44.920 --> 00:06:51.480
 key code, you can press Control H and then a help buffer pops up with a listing of all

00:06:51.480 --> 00:06:56.280
 key bindings that start with Control X. The information is the same, the presentation is

00:06:56.280 --> 00:07:03.520
 different because now if I wanted to do Control X, I have to repeat the entire key code again.

00:07:03.520 --> 00:07:09.640
 So it's a matter of personal preference, which you prefer. This is more of a traditional

00:07:09.640 --> 00:07:19.440
 static approach, because of course I get a help buffer where I can, which I can search

00:07:19.440 --> 00:07:28.520
 and use in usual key commands, which key is more of a transient and modern, some might

00:07:28.520 --> 00:07:37.080
 say, some might prefer that approach to solving the same problem. Also, don't forget to check

00:07:37.080 --> 00:07:42.480
 out the customization group for which key, which has a number of options which you might

00:07:42.480 --> 00:07:51.800
 or might not be trusted in. Next up, Emax30 has built-in editor conflict support. If you

00:07:51.800 --> 00:07:56.600
 have not heard of editor conflict before, believe I've linked to it down here somewhere,

00:07:56.600 --> 00:08:10.200
 there it is, editor conflict. This is a file format used to specify common, common formatting

00:08:10.200 --> 00:08:18.140
 rules in an editor-agnostic way. You might compare it to der local files, which is a sort

00:08:18.140 --> 00:08:24.880
 of an S expression for setting file local variables in Emax, but of course this is restricted

00:08:24.880 --> 00:08:31.960
 to the common subset of what all editors should understand, for example, indentation styles,

00:08:31.960 --> 00:08:39.680
 whether they prefer tabs or spaces and tab with filing, coding and so on. So it's nothing

00:08:39.680 --> 00:08:49.680
 to advance, but it is a file format, which one sees, popping up more and more often in

00:08:49.680 --> 00:08:55.060
 a lot of projects which want to enforce a consistent indentation style or formatting rules for

00:08:55.060 --> 00:09:00.780
 all editors in a project. Having this built-in is certainly useful in Emax, though we should

00:09:00.780 --> 00:09:11.120
 note that it's not enabled by default, so you still have to enable the global minimum,

00:09:11.120 --> 00:09:16.600
 which is simply turning on this one option. It shouldn't be more than that, and then Emax

00:09:16.600 --> 00:09:24.400
 will respect the rules. If it finds an editor-conflict file in the project directory, then it will

00:09:24.400 --> 00:09:28.960
 respect those rules without having to do anything else.

00:09:28.960 --> 00:09:37.680
 Next up, use package integration with Package Vc. So for those of you familiar with the two

00:09:37.680 --> 00:09:47.160
 words, names, next up, use package integration with Package Vc. For those of you familiar with

00:09:47.160 --> 00:09:52.760
 either of the two or at least one of the two, use package is a popular configuration marker.

00:09:52.760 --> 00:09:59.400
 What it does is it allows users to declaratively specify packages they'd like to have installed

00:09:59.400 --> 00:10:06.040
 and configured in their configuration file. So that, for example, if you copy your init.cl

00:10:06.040 --> 00:10:10.920
 from one system to another, it could bootstrap the entire configuration, downloading all

00:10:10.920 --> 00:10:16.640
 the packages you want, without having to manually do this on every system you'd like to use,

00:10:16.640 --> 00:10:25.240
 which allows configurations to be self encapsulated and portable. Package Vc is an extension of Package

00:10:25.240 --> 00:10:32.680
 EL, which allows installing packages from an alternative or instead of using the standard

00:10:32.680 --> 00:10:38.840
 way to install packages, which is just down the target and on the package, like compilers

00:10:38.840 --> 00:10:46.740
 and so on, it will fetch the files for a package directly from the source code repository

00:10:46.740 --> 00:10:52.160
 and initialize it in such a way that Package EL can work with it. So it's just a front-end

00:10:52.160 --> 00:10:58.600
 for installing packages. Even though these two are added the next 29, we didn't have the

00:10:58.600 --> 00:11:04.720
 time to work on the use package integration of Package Vc into use package, which has been

00:11:04.720 --> 00:11:14.560
 changed now. So what we have with Emex29 is that we can, there is a Vc keyword for use package

00:11:14.560 --> 00:11:22.400
 with which we can instruct use package to not download a package using table, but instead

00:11:22.400 --> 00:11:27.200
 to fetch the source code from a source code repository. This is useful if you, for example,

00:11:27.200 --> 00:11:32.040
 have packages which you yourself work on and know that you always want to have the development

00:11:32.040 --> 00:11:39.720
 version of the package where you can directly commit changes you've made to the repository

00:11:39.720 --> 00:11:44.160
 and push them upstream, or if you know that you want to contribute to a package, you can

00:11:44.160 --> 00:11:48.960
 use Package Vc to download the source code, have all the version of the total information,

00:11:48.960 --> 00:11:56.920
 prepare a patch and send it upstream. In these examples here, we have, once the

00:11:56.920 --> 00:12:05.020
 first example lists, instructs Package Vc to download the source code from a URL. So this

00:12:05.020 --> 00:12:09.400
 is a GIT URL where it will download the source code from, and in this case, choose the

00:12:09.400 --> 00:12:15.040
 new list checkout of the source code, not the latest release. And down here we have another

00:12:15.040 --> 00:12:21.880
 example, or I prefer to consider the following example here, if we just had wrote written

00:12:21.880 --> 00:12:28.520
 this, then Package Vc would use the metadata which an helper server provides to fetch the

00:12:28.520 --> 00:12:35.360
 URL from the official repository of, in this case, BBDP without having to, so it would

00:12:35.360 --> 00:12:42.280
 be more or less the same like this up here, with a simple or with a single difference

00:12:42.280 --> 00:12:48.240
 that Package Vc integration into use package doesn't check out the latest, the latest commit

00:12:48.240 --> 00:12:56.880
 but the latest release, just to keep configurations more deterministic by default. Of course, if

00:12:56.880 --> 00:13:04.800
 you prefer to use latest commit, you can use the Package Vc install command, or just update

00:13:04.800 --> 00:13:14.040
 the Package manually yourself, which you can use using Package Vc upgrade. Next, I'd like

00:13:14.040 --> 00:13:19.560
 to focus on a few features which one might next necessarily realize directly, but will

00:13:19.560 --> 00:13:26.800
 hopefully improve your experience with Emacs. First up, in this list is a new JSON parser,

00:13:26.800 --> 00:13:43.880
 let's maybe show the source code for that one, and I'll now JSON.dr, JSON, yeah, JSON.c.

00:13:43.880 --> 00:13:54.960
 For those, the history of JSON parsing Emacs started with Emacs 23 with the addition of JSON.dr,

00:13:54.960 --> 00:14:02.600
 this was a file which we have just opened a moment ago. This is a JSON parser in Emacs.lisp,

00:14:02.600 --> 00:14:07.760
 it's fine, it does the job, but it can get slow if we have a situation like where Eglot

00:14:07.760 --> 00:14:14.800
 uses a sp server to communicate with it, and the sp server can get a bit chatty, sending

00:14:14.800 --> 00:14:20.520
 a lot of JSON data, which all has to be parsed and garbage collected, which can slow down

00:14:20.520 --> 00:14:27.800
 Emacs a bit. The situation was improved upon in Emacs 29 with the addition or when JSON

00:14:27.800 --> 00:14:32.720
 parsing was added to the core, this was the JSON.c file, which we see on this side of the

00:14:32.720 --> 00:14:39.320
 old version of JSON.c file, which employed the Janssen library, it's the C library for parsing

00:14:39.320 --> 00:14:47.040
 and accelerating JSON parsing in Emacs. This was good enough, or it certainly improved

00:14:47.040 --> 00:14:52.600
 the situation for lots of LSP clients, but in Emacs 30, the situation has been improved

00:14:52.600 --> 00:15:02.560
 one small by implementing or with the addition of a JSON parser directly in Emacs. So instead

00:15:02.560 --> 00:15:09.360
 of using an external library, there's a custom JSON parser written in C in the Emacs core,

00:15:09.360 --> 00:15:17.240
 which directly generates Eglot objects. The advantage to this approach, compared to the

00:15:17.240 --> 00:15:21.680
 Janssen approach, is that there's no intermediate form at which has to be allocated and memory

00:15:21.680 --> 00:15:31.360
 managed and freeed again, which of course incurs an additional performance overhead.

00:15:31.360 --> 00:15:37.040
 Next to this is also a custom serializing for JSON contents, so translating a JSON object

00:15:37.040 --> 00:15:44.040
 into a string, meaning that the consequence of this is that there is absolutely no dependency

00:15:44.040 --> 00:15:51.320
 on Janssen anymore. This in turn means that now all Emacs users from Emacs 30 onwards

00:15:51.320 --> 00:15:56.600
 can take advantage of this new JSON parser and don't have to worry about whether or not

00:15:56.600 --> 00:16:01.720
 they have Janssen, this JSON parsing library installed on this system or not, when they want

00:16:01.720 --> 00:16:12.160
 to take advantage of this accelerated JSON parsing. Next up, another behind the scenes feature

00:16:12.160 --> 00:16:19.440
 is that if you build Emacs on your own from source, you might know that if you want

00:16:19.440 --> 00:16:27.120
 to use native compilation, so the translation of elus bytecode to whatever the native assembly

00:16:27.120 --> 00:16:36.080
 or native instruction set is on your system, you had to specify with native compilation

00:16:36.080 --> 00:16:40.880
 when voting the configure script, otherwise it would not have been enabled at all. With Emacs

00:16:40.880 --> 00:16:47.440
 30, this step is not necessary anymore. In case the configure script will automatically

00:16:47.440 --> 00:16:54.880
 check if you have the lib gcc jits library installed on your system and if that is so, then

00:16:54.880 --> 00:16:59.760
 native compilation will be enabled by default. In other words, if you have an issue with

00:16:59.760 --> 00:17:05.360
 native compilation or prefer not to use it for whatever reason, you never have to type

00:17:05.360 --> 00:17:11.360
 without native compilation when compiling Emacs to prevent this from happening. But native

00:17:11.360 --> 00:17:16.840
 compilation was added in Emacs 28 and has proven to be a very stable and useful feature

00:17:16.840 --> 00:17:22.400
 for most people. So there's probably no reason to do this and you can just invoke the configure

00:17:22.400 --> 00:17:29.240
 script with one argument less. Right, and I'd like to finish up with a few smaller features,

00:17:29.240 --> 00:17:38.920
 a few smaller highlights. Maybe we can go back to this thing here. First up is, whoops,

00:17:38.920 --> 00:17:46.360
 here we have it, there are a few new major modes based on the Tristeter library. Tristeter

00:17:46.360 --> 00:17:55.560
 is this parser library, which has been integrated into Emacs 29 that allows or it allows the integration

00:17:55.560 --> 00:18:02.600
 of external specialized and quick parses into Emacs, which improves stuff like syntax highlighting,

00:18:02.600 --> 00:18:09.720
 indentation, structural navigation. I many supports by simply having a better understanding

00:18:09.720 --> 00:18:15.640
 of an elisp file or not an elisp file of, for example, a HTML file or a Lua file, a PHP file,

00:18:15.640 --> 00:18:23.080
 and what people usually implement using regular expressions in traditional major modes. So a

00:18:23.080 --> 00:18:30.600
 few new major modes, which you can try out here. Another interesting feature is the completion

00:18:30.600 --> 00:18:36.280
 preview mode. You can maybe try it out here in this scratch buffer. If I enable complete

00:18:37.480 --> 00:18:47.560
 sound preview mode, this is a local and non-global minor mode, which will display completion options

00:18:47.560 --> 00:18:55.400
 in inline using overlays. For example, if I start typing along the symbol like define, yeah,

00:18:55.400 --> 00:19:02.120
 now we had a derived mode, it suggests me to, I can just press tab and then it completes the

00:19:02.120 --> 00:19:07.560
 option here, but it didn't actually, it's not actually modifying the buffer, it's not pressing, these

00:19:07.560 --> 00:19:13.000
 are just overlays. So if I move around, it gets deleted, it wouldn't get saved if I was saved the buffer.

00:19:13.000 --> 00:19:19.560
 The same also should work in a shell buffer, so if I enable completion preview mode here and starts,

00:19:19.560 --> 00:19:26.040
 in this case, I'm using the bash completion package, which provides additional completion

00:19:26.040 --> 00:19:31.480
 information, so this is not only limited to programming systems, but anywhere where you have

00:19:31.480 --> 00:19:37.960
 completion at point. If I can start typing here, ignore, but ignore backups, and it's

00:19:37.960 --> 00:19:42.920
 hints to the options which I have and allows me to complete them quickly.

00:19:42.920 --> 00:19:52.280
 Another small feature is the package isolate command. What this does is it will start, or it will

00:19:52.280 --> 00:19:58.360
 prompt me for a few, for packages I have installed in my system, and will start an isolated, or

00:19:58.360 --> 00:20:05.960
 like EMEX-Q-ish instance of EMEX, with only these packages installed. So for example, if I set

00:20:05.960 --> 00:20:16.040
 I1-slime, and I1-dif-hl, then this is a new EMEX window, it's unrelated to the one around, it

00:20:16.040 --> 00:20:20.360
 uses the same executable, of course, but will not load your configuration file,

00:20:20.360 --> 00:20:27.960
 or any other further customizations on your system. All it does, it will ensure that these packages,

00:20:27.960 --> 00:20:34.520
 which are listed here. So in RK-slime, and dependencies of Slime, and Dif-hl,

00:20:34.520 --> 00:20:43.400
 in the system, so that I could, for example, as you can see here, Dif-hl mode worked by,

00:20:43.400 --> 00:20:48.600
 okay, this is not a version controlled file, maybe if we take a look at

00:20:48.600 --> 00:20:57.320
 by enabled Dif-hl mode, it's enabled, in this case, what Dif-hl mode does is it displays these

00:20:58.280 --> 00:21:02.760
 version controlled changes in the fringe of a buffer, and even though this is a

00:21:02.760 --> 00:21:10.040
 un-customized version of EMEX, or un-customized instance of EMEX, it was easy for me to load this one

00:21:10.040 --> 00:21:15.320
 package, or these two packages, and all the dependencies necessary. As you can imagine, the main

00:21:15.320 --> 00:21:22.280
 purpose for this is to make debugging issues easier, if you want to report an issue, you have

00:21:22.280 --> 00:21:27.400
 all the package, and if I close this, it's closed, and everything is thrown away.

00:21:27.400 --> 00:21:34.200
 Last up a nice feature, I think a lot of people will appreciate is if you are familiar with,

00:21:34.200 --> 00:21:40.520
 let's open a text buffer, the Metacube key, Metacube is traditionally bound to fill a paragraph,

00:21:40.520 --> 00:21:46.760
 what this means is now, so let's, for example, copy this text from here, and

00:21:49.080 --> 00:21:53.960
 squash it all into one line, if I press Metacube here, then the lines will be broken

00:21:53.960 --> 00:22:03.960
 according to the fill column indicator up here. This is a traditional usage of Metacube,

00:22:03.960 --> 00:22:10.440
 and it still works in text mode buffers, but in prog mode buffers, so any major mode inheriting

00:22:10.440 --> 00:22:18.840
 prog mode, Metacube will now by default be bound to prog fill re-indense defun. What is basically

00:22:18.840 --> 00:22:25.960
 or to summarize the points, if you are editing a string, then or a comment, then the comment will

00:22:25.960 --> 00:22:33.960
 be filled, but if you are outside of a comment or outside of a string, then the defun or the top level

00:22:33.960 --> 00:22:42.520
 construct in the programming language will be re-indented. Let's try that out with maybe some file I have

00:22:42.520 --> 00:22:53.560
 open here, if I'm in this, let's choose some function, let's take this example. If we follow

00:22:53.560 --> 00:23:00.920
 the order of this again, and I press Metacube in on this paragraph, then the paragraph gets re-indented,

00:23:00.920 --> 00:23:07.080
 but if I'm down here, and I choose to break the indentation and then press Metacube,

00:23:07.800 --> 00:23:15.320
 then as you see, only then it's practically selected the defun and re-indented everything without

00:23:15.320 --> 00:23:20.600
 having to move the points around in the buffer. So I think that's a really nice feature,

00:23:20.600 --> 00:23:27.720
 which a lot of people can appreciate, it's one of those niceties, which come from time to time.

00:23:27.720 --> 00:23:35.640
 So that was my overview of what's going to be new in Emacs 30. I hope that most people could take

00:23:35.640 --> 00:23:41.960
 away something from this presentation and have something to look forward to, to try out after

00:23:41.960 --> 00:23:47.880
 upgrading. As mentioned initially, as of recording, this release has not been completed yet,

00:23:47.880 --> 00:23:52.760
 and if this is still not the case as soon as when you're seeing this video, please consider

00:23:52.760 --> 00:23:59.960
 downloading and building Emacs 30 yourself. And if you have any issues, which is always the case,

00:23:59.960 --> 00:24:09.160
 please report them to using Emacs, what's going to report Emacs, but that will pop up a mail buffer,

00:24:09.160 --> 00:24:13.480
 and then you can describe your shouldn't send them out. All bug reports are valuable,

00:24:13.480 --> 00:24:18.840
 even if they are false positives or duplicates, it doesn't matter, because when you take the time to

00:24:18.840 --> 00:24:24.360
 submit a bug report, which describes something that's specific to your setup, what should the

00:24:24.360 --> 00:24:30.360
 developers might not have noticed or known about, and you are certainly helping out a lot of other

00:24:30.360 --> 00:24:34.840
 people, which might run into the same issue in the future. And especially with upgrades,

00:24:34.840 --> 00:24:42.520
 it would be nice to figure out small problems, which make upgrading difficult for some people.

00:24:42.520 --> 00:24:46.920
 The idea is, of course, the idea is, of course, to have no issues when upgrading from one

00:24:46.920 --> 00:24:55.080
 verge to another. Having said that, I thank you for your attention and I'm saying goodbye.

